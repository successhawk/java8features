package io.github.successhawk.java8features.lambdas.basics;

public class LambdaBasicsExample {

	public static void simpleThread_PreJava8() {
		/* The pre-Java 8 way required an anonymous inner class. 2 examples below with subtle differences. */
		
		/* Here is an example instantiating an Anonymous inner class that extends Thread directly */
		new Thread() {
			public void run() {
				System.out.println("simpleThread_PreJava8: My thread is " + Thread.currentThread());;
			};
		}.start();
		
		/* Here is an example instantiating an Anonymous inner class that implements Runnable and passing it to Thread's constructor.
		 * The Java 8 approach will be closer  */
		new Thread(new Runnable() {
			public void run() {
				System.out.println("simpleThread_PreJava8: My thread is " + Thread.currentThread());;
			};
		}).start();
		System.out.println("simpleThread_PreJava8: My thread is " + Thread.currentThread());
	}

	public static void simpleThread_Java8() {
		/* This is effectively the same as the 2nd example in simpleThread_PreJava8()
		 * , but you can see that the new Lambda syntax "()->" is much less verbose/boilerplate.
		 * Also, the generated bytecode is very different.  First of all, the Lambda is compiled into the same class file,
		 * whereas each anonymous inner class is compiled into as separate class files like ContainingClass$1.class, ContainingClass$2.class, ...  I'm guessing they didn't want a file explosion, 
		 * since lambdas will be used more often. */
		new Thread(()->System.out.println("simpleThread_Java8: My thread is " + Thread.currentThread())).start();
		System.out.println("simpleThread_Java8: My thread is " + Thread.currentThread());
	}
	
	public static void main(String[] args) {
		simpleThread_PreJava8();
		simpleThread_Java8();
	}
}
